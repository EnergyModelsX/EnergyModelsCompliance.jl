var documenterSearchIndex = {"docs":
[{"location":"manual/quick-start/#man-quick","page":"Quick Start","title":"Quick Start","text":"Install the most recent version of Julia\nInstall the package EnergyModelsBase, the time package TimeStruct, and EnergyModelsCompliance by running:\n] add EnergyModelsBase\n] add TimeStruct\n] add EnergyModelsCompliance","category":"section"},{"location":"manual/use/#man-use","page":"How to use","title":"How to use the package","text":"","category":"section"},{"location":"manual/use/#man-use-concepts","page":"How to use","title":"Introduced concepts","text":"Compliance with the EnergyModelsX framework requires in general that\n\ndeveloped access and identification functions are available for the new elements, and\nthe new elements can be used within the framework without providing trivial solutions.\n\nTo this end, two functions are created.","category":"section"},{"location":"manual/use/#man-use-concepts-acc_ident","page":"How to use","title":"Access and identification functions","text":"The function compliance_element investigates whether the currently used functions are working for the new element. The function automatically deduces the supertype and calls the relevant subfunctions for the given element supertype. Aside from printing errors and warnings, it returns two NamedTuple in which the values correspond to Booleans.\n\nThe first NamedTuple corresponds to the errors from the compliance checks. Errors are recorded when the model would not build. An example for such a function is inputs. This function is called within the core structure of EnergyModelsBase, and hence, must both be applicable and return a Vector{<:Resource} as output.\n\nThe second NamedTuple corresponds to the warnings from the compliance checks. Warnings imply that there may be a problem, if base functionality is utilized. In this case, the model would not construct. However, if a developer provide new methods for their developed node, it is possible to ignore the warnings. An example is given by the function opex_fixed. This function is only called in the function constraints_opex_fixed. Hence, if you do not use the function, you can ignore the warning.","category":"section"},{"location":"manual/use/#man-use-concepts-test","page":"How to use","title":"Test case","text":"The function test_case can be used to create a simple test case for the developed element. It is implemented for both new Nodes and TransmissionModes. It should be used for identifying whether the developed element results in a trivial solution, that is no energy conversion or transmission.\n\nThe function creates a minimum working example given an instance of the element, a simple time structure, and the warn_log from the function compliance_element. It then tests whether the new element is utilized.\n\nnote: Tested values\nThe utilization is tested by the variable :cap_use of the connected Nodes and a corresponding utilization value of the new Node or TransmissionMode. It must be above 0.1 in at least one of the time periods for all connected Nodes. The tests for the node itself are::cap_use of the developed Node is larger than 0.1 at least once.\n:stor_level of the developed Storage is larger than 0.1 at least once. :stor_charge_use an/or stor_discharge_use must also be above 0.1 at least once depending on whether the Storage node has input or output.\n:trans_in and :trans_out of the developed TransmissionMode is larger than 0.1 at least once.You must adjust your test case that they are working with these test values.This is also explained in the respective docstrings test_case(n::Source, ð’¯::TimeStructure, warn; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0)) and test_case(tm::TransmissionMode, ð’¯::TimeStructure, warn; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0)).\n\n.\n\nThere are however a few important caveats when using the function for Nodes.\n\nIf your node includes COâ‚‚ capture or process emissions, you must specify the keyword argument co2 with your COâ‚‚ instance.\nIf you use JuMP.fix for fixing storage charge or discharge variables, that is not providing a new method for has_input or has_output, some of the tests may fail. These functions are in this case related to :cap_use of a source or sink, as well a :stor_charge_use or :stor_discharge_use.\nThe function does not allow that the specified COâ‚‚ instance (through the keyword argument co2) is an input to the developed node.\nThe function is not designed to evaluate a required sequence of linked nodes. As an example, CCS retrofit requires the direct coupling of the node with a NetworkNode. This cannot be generalized.\nIf you test a Sink node without a fixed demand, you must provide parameters so that it is beneficial to deliver energy to the sink node. This can be achieved through receiving a profit.\n\nwarning: Rigorous testing\nThe developed function should only be used for identifying major problems with new elements. It does not provide a rigorous test for the new element. This is especially relevant for the mathematical formulation, as we cannot include automated tests for unknown mathematical formulations. It is hence necessary that you test your element further with changes in the input representing your specific element.","category":"section"},{"location":"manual/use/#man-use-examples","page":"How to use","title":"Examples","text":"For the content of the individual examples, see the examples directory in the project repository. The examples are commented to show how the package can be utilized.\n\nnote: Note\nThe examples should provide you with an idea how to call the introduced functions. They use existing elements from different EnergyModelsX packages which are complying with the framework. They hence illustrate more the required input to the functions.","category":"section"},{"location":"manual/philosophy/#man-phil","page":"Philosophy","title":"Philosophy","text":"The aim of the EnergyModelsX framework is to provide the user with an extensible energy system optimization framework in which the user can add new technology descriptions without changes to the core structure of the framework. Introducing new technology descriptions is for example explained in how to create a new element and how to create a new node. However, these new elements must satisfy certain criteria to work seamless wihin EnergyModelsX.\n\nEnergyModelsCompliance provides the user with compatibility checks for new developed subtypes of Nodes and Links, both introduced in EnergyModelsBase, and  Areas and  TransmissionModes, both introduced in EnergyModelsGeography. These functions, explained in How to use the package, can be utilized for identifying potential problems when incorporating new subtypes for the elements outlined above.","category":"section"},{"location":"library/internal/#lib-int","page":"Internal","title":"Internal library","text":"","category":"section"},{"location":"library/internal/#lib-int-idx","page":"Internal","title":"Index","text":"Pages = [\"internal.md\"]","category":"section"},{"location":"library/internal/#lib-int-node_link","page":"Internal","title":"Nodes and Links","text":"","category":"section"},{"location":"library/internal/#lib-int-area_mode","page":"Internal","title":"Areas and TransmissionModes","text":"","category":"section"},{"location":"library/internal/#EnergyModelsCompliance.compliance_capacity-Tuple{EnergyModelsBase.Node}","page":"Internal","title":"EnergyModelsCompliance.compliance_capacity","text":"compliance_capacity(n::EMB.Node)\n\nReturns a Bool indicating whether the function capacity is applicable for the developed Node.\n\nThe function checks both capacity(n) and capacity(n, t) even if the former is not directly used.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_opex_var-Tuple{EnergyModelsBase.Node}","page":"Internal","title":"EnergyModelsCompliance.compliance_opex_var","text":"compliance_opex_var(n::EMB.Node)\ncompliance_opex_var(n::Sink)\n\nReturns a Bool indicating whether the function opex_var is applicable for the developed Node or alternatively the functions surplus_penalty and deficit_penalty.\n\nThe function checks both opex_var(n) (surplus_penalty(n) and deficit_penalty(n)) and opex_var(n, t) (surplus_penalty(n, t) and deficit_penalty(n, t)) even if the former is not directly used.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_opex_fixed-Tuple{EnergyModelsBase.Node}","page":"Internal","title":"EnergyModelsCompliance.compliance_opex_fixed","text":"compliance_opex_fixed(n::EMB.Node)\ncompliance_opex_fixed(n::Sink)\n\nReturns a Bool indicating whether the function opex_fixed is applicable for the developed Node.\n\nThe function checks both opex_fixed(n) and opex_fixed(n, t_inv) even if the former is not directly used.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_inputs-Tuple{EnergyModelsBase.Node}","page":"Internal","title":"EnergyModelsCompliance.compliance_inputs","text":"compliance_inputs(n::EMB.Node)\n\nReturns a Tuple{Bool} indicating whether the function inputs is applicable for the developed Node.\n\nThe first entry of the Tuple is indicating whether the model can build while the second entry indicates whether problems with existing base functions may occur.\n\nThe function checks both inputs(n) and inputs(n, p).\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_outputs-Tuple{EnergyModelsBase.Node}","page":"Internal","title":"EnergyModelsCompliance.compliance_outputs","text":"compliance_outputs(n::EMB.Node)\n\nReturns a Tuple{Bool} indicating whether the function outputs is applicable for the developed Node.\n\nThe first entry of the Tuple is indicating whether the model can build while the second entry indicates whether problems with existing base functions may occur.\n\nThe function checks both outputs(n) and outputs(n, p).\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_data-Tuple{EnergyModelsBase.Node}","page":"Internal","title":"EnergyModelsCompliance.compliance_data","text":"compliance_data(n::EMB.Node)\n\nReturns a Bool indicating whether the function node_data is applicable for the developed Node.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_level","page":"Internal","title":"EnergyModelsCompliance.compliance_level","text":"compliance_level(n::Storage)\n\nReturns a Bool indicating whether the function level is applicable for the developed Storage.\n\n\n\n\n\n","category":"function"},{"location":"library/internal/#EnergyModelsCompliance.compliance_stor_res","page":"Internal","title":"EnergyModelsCompliance.compliance_stor_res","text":"compliance_stor_res(n::Storage)\n\nReturns a Bool indicating whether the function storage_resource is applicable for the developed Storage.\n\n\n\n\n\n","category":"function"},{"location":"library/internal/#EMGExt.compliance_area_availability","page":"Internal","title":"EMGExt.compliance_area_availability","text":"compliance_area_availability(a::Area)\n\nReturns a Bool indicating whether the function availability_node is applicable for the developed Area.\n\n\n\n\n\n","category":"function"},{"location":"library/internal/#EnergyModelsCompliance.compliance_capacity-Tuple{TransmissionMode}","page":"Internal","title":"EnergyModelsCompliance.compliance_capacity","text":"EMC.compliance_capacity(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function capacity is applicable for the developed Node.\n\nThe function checks both capacity(tm) and capacity(tm, t) even if the former is not directly used.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_opex_var-Tuple{TransmissionMode}","page":"Internal","title":"EnergyModelsCompliance.compliance_opex_var","text":"EMC.compliance_opex_var(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function opex_var is applicable for the developed TransmissionMode.\n\nThe function checks both opex_var(tm) and opex_var(tm, t) even if the former is not directly used.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_opex_fixed-Tuple{TransmissionMode}","page":"Internal","title":"EnergyModelsCompliance.compliance_opex_fixed","text":"EMC.compliance_opex_fixed(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function opex_fixed is applicable for the developed TransmissionMode.\n\nThe function checks both opex_fixed(tm) and opex_fixed(tm, t_inv) even if the former is not directly used.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_inputs-Tuple{TransmissionMode}","page":"Internal","title":"EnergyModelsCompliance.compliance_inputs","text":"EMC.compliance_inputs(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function inputs is applicable for the developed TransmissionMode.\n\nThe first entry of the Tuple is indicating whether the model can build while the second entry is always false.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_outputs-Tuple{TransmissionMode}","page":"Internal","title":"EnergyModelsCompliance.compliance_outputs","text":"EMC.compliance_outputs(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function outputs is applicable for the developed TransmissionMode.\n\nThe first entry of the Tuple is indicating whether the model can build while the second entry is always false.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EnergyModelsCompliance.compliance_data-Tuple{TransmissionMode}","page":"Internal","title":"EnergyModelsCompliance.compliance_data","text":"EMC.compliance_data(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function mode_data is applicable for the developed TransmissionMode.\n\n\n\n\n\n","category":"method"},{"location":"library/internal/#EMGExt.compliance_loss","page":"Internal","title":"EMGExt.compliance_loss","text":"compliance_loss(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function loss is applicable for the developed TransmissionMode.\n\nThe function checks both loss(tm) and loss(tm, t) even if the former is not directly used.\n\n\n\n\n\n","category":"function"},{"location":"library/internal/#EMGExt.compliance_bidirectional","page":"Internal","title":"EMGExt.compliance_bidirectional","text":"compliance_bidirectional(tm::TransmissionMode)\n\nReturns a Bool indicating whether the function is_bidirectional is applicable for the developed TransmissionMode.\n\nIt is not required if you create a new PipeMode.\n\n\n\n\n\n","category":"function"},{"location":"library/internal/#EMGExt.compliance_con_rate","page":"Internal","title":"EMGExt.compliance_con_rate","text":"compliance_con_rate(tm::TransmissionMode)\ncompliance_con_rate(tm::PipeMode)\n\nReturns a Bool indicating whether the function consumption_rate is applicable for the developed TransmissionMode.\n\nIt is only required if you create a new PipeMode.\n\nThe function checks both consumption_rate(tm) and consumption_rate(tm, t) even if the former is not directly used.\n\n\n\n\n\n","category":"function"},{"location":"#EnergyModelsCompliance","page":"Home","title":"EnergyModelsCompliance","text":"EnergyModelsCompliance is a utility package for the EnergyModelsX framework focusing on providing the user with functionality to check whether newly developed element descriptions are complying with the framework. These functions are included for both EnergyModelsBase and EnergyModelsGeography.\n\nIt should be utilized for obtaining an overview of potential problems, but not as substitution for rigorous testing.","category":"section"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"Pages = [\n    \"manual/quick-start.md\",\n    \"manual/philosophy.md\",\n    \"manual/use.md\",\n    \"manual/NEWS.md\",\n]\nDepth = 1","category":"section"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"Pages = [\n    \"library/public.md\",\n    \"library/internal.md\",\n]\nDepth = 1","category":"section"},{"location":"library/public/#lib-pub","page":"Public","title":"Public library","text":"","category":"section"},{"location":"library/public/#lib-pub-idx","page":"Public","title":"Index","text":"Pages = [\"public.md\"]","category":"section"},{"location":"library/public/#lib-pub-node_link","page":"Public","title":"Nodes and Links","text":"","category":"section"},{"location":"library/public/#lib-pub-area_mode","page":"Public","title":"Areas and TransmissionModes","text":"","category":"section"},{"location":"library/public/#EnergyModelsCompliance.compliance_element-Tuple{EnergyModelsBase.Node}","page":"Public","title":"EnergyModelsCompliance.compliance_element","text":"compliance_element(n::EMB.Node)\ncompliance_element(n::Storage)\ncompliance_element(l::Link)\n\nReturns two NamedTuples corresponding to respectively the errors and warnings of the testing of the indivdiual test functions. The called test functions are dependent on the chosen type:\n\nnote: Node\nThe following functions are called:compliance_capacity, not for Storage nodes,\ncompliance_opex_var, not for Storage nodes,\ncompliance_opex_fixed, not for Storage nodes,\ncompliance_inputs, if the node has an input, checked through the function has_input,\ncompliance_outputs, if the node has an output, checked through the function has_output,\ncompliance_data,\ncompliance_level for Storage nodes, including a check that the level is corresponding to an AbstractStorageParameters, and\ncompliance_stor_res for Storage nodes.\n\ntip: Link\nLinks are more flexible than Nodes. As a consequence, we do not check whether the access functions are working. Instead, it is checked whether Links have the fields :from and :to and that either of them is restricted to a n.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#EnergyModelsCompliance.test_case-Tuple{Source, TimeStructure, Any}","page":"Public","title":"EnergyModelsCompliance.test_case","text":"test_case(n::Source, ð’¯::TimeStructure, warn_log; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0))\ntest_case(n::NetworkNode, ð’¯::TimeStructure, warn_log; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0))\ntest_case(n::Storage, ð’¯::TimeStructure, warn_log; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0))\ntest_case(n::Sink, ð’¯::TimeStructure, warn_log; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0))\n\nDefault testset which tests that the developed Node n can be included in an EnergyModelsBase model, and that the resulting model is solvable.\n\nThe testset automatically identifies a minimum working case for the given node structure and solves this case. The Source node of the example has in all versions (except if you test a source node) a variable OPEX of 0. This implies, that if you test a Sink node without a fixed demand, you must provide parameters so that it is beneficial to deliver energy to the sink node. This can be achieved through receiving a profit.\n\nThe same holds for a case in which you have a Storage node without an output.\n\nThe following default values are chosen:\n\nIf we cannot use the function capacity, we use a capacity of 100. Otherwise, the capacity is sufficient for the capacity of the node.\nIf we cannot use the function opex_var (in all cases except for n::Sink), we assume it is 2500 for calculating the penalties of the Sink.\n\nwarning: Potential problems with the function\nIf you use JuMP.fix for fixing storage charge or discharge variables, that is not providing a new method for has_input or has_output, some of the tests may fail. These functions are in this case related to :cap_use of a source or sink, as well as :stor_charge_use or :stor_discharge_use.\nThe function is not working properly if you have the co2 keyword argument as input to your node.\nThe function is not designed to evaluate a required sequence of linked nodes. As an example, CCS retrofit requires the direct coupling of two nodes. This cannot be generalized.\nThe function cannot be used for a link as you would need to provide Nodes as values for the fields :from and :to.\n\nArguments\n\nn::EMB.Node is the node that is tested.\nð’¯::TimeStructure is the chosen time structure. It should only contain a single strategic period.\nwarn_log is the warning NamedTuple obtained through calling the function compliance_element.\n\nKeyword arguments\n\nco2::ResourceEmit is the COâ‚‚ resource in the model. If your node does not include COâ‚‚, you do not have to specify it.\n\nTests\n\nThe optimization problems leads to an optimal solution.\nThe variable :cap_use of all connected nodes is above 0.1 in at least one of the time periods.\n\ntip: Source, NetworkNode, and Sink\nWe test furthermore:The variable :cap_use of the node n is above 0.1 in at least one of the time periods.\n\nnote: Storage\nStorage nodes use a random source variable OPEX and a fixed sink demand to analyse the changes in the storage level. This implies that if the Storage node does not have an output, then it is crucial that it is beneficial to store the Resource. This can be achieved through negative OPEX terms that must be above We test furthermore:The variables :stor_level, :stor_charge_use, and :stor_discharge_use of the node n are above 0.1 in at least one of the time periods.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#EnergyModelsCompliance.compliance_element-Tuple{Area}","page":"Public","title":"EnergyModelsCompliance.compliance_element","text":"EMC.compliance_element(a::Area)\nEMC.compliance_element(tm::TransmissionMode)\n\nReturns two NamedTuples corresponding to respectively the errors and warnings of the testing of the indivdiual test functions. The called test functions are dependent on the chosen type:\n\nnote: TransmissionMode\nThe following functions are called:EMC.compliance_capacity,\nEMC.compliance_opex_var, if the TransmissionMode has OPEX, checked through the function has_opex,\nEMC.compliance_opex_fixed, if the TransmissionMode has OPEX, checked through the function has_opex,\nEMC.compliance_inputs,\nEMC.compliance_outputs,\nEMC.compliance_data,\ncompliance_loss for PipeMode,\ncompliance_con_rate for PipeMode, and\ncompliance_bidirectional.warning: Warning\nEMC.compliance_data is in the current stage removed due to changes to the handling of ExtensionData.\n\nnote: Areas\nThe following function is called:compliance_area_availability.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#EnergyModelsCompliance.test_case-Tuple{TransmissionMode, TimeStructure, Any}","page":"Public","title":"EnergyModelsCompliance.test_case","text":"EMC.test_case(tm::TransmissionMode, ð’¯::TimeStructure, warn_log; co2::ResourceEmit = ResourceEmit(\"COâ‚‚\", 1.0))\n\nDefault testset which tests that the developed TransmissionMode tm can be included in an EnergyModelsGeography model, and that the resulting model is solvable.\n\nThe testset automatically identifies a minimum working case for the given transmission mode structure. The minimum working example includes 2 areas that are only connected by the given TransmissionMode. Area 1 is the :from area and includes sources for supplying all inputs of the TransmissionMode. Area 2 is the :to area and includes sinks for all outputs of the TransmissionMode. Both areas also include the opposite if bidirectional transport is allowed. In this case, the profit is positive in either area 1 or area 2.\n\nThe following default values are chosen:\n\nIf we cannot use the function capacity, we use a capacity of 100. Otherwise, the capacity is sufficient for the capacity of the mode.\nThe profit in the sinks is 150 and the penalty 1e4.\n\nArguments\n\ntm::TransmissionMode is the transmission mode that is tested.\nð’¯::TimeStructure is the chosen time structure. It should only contain a single strategic period.\nwarn_log is the warning NamedTuple obtained through calling the function compliance_element.\n\nTests\n\nThe optimization problems leads to an optimal solution.\nThe variable :cap_use of all connected nodes is above 0.1 in at least one of the time periods. All source and sink nodes in the two areas are checked.\nThe variables :trans_in and :trans_out are above 0.1 in at least one of the time periods.\n\n\n\n\n\n","category":"method"},{"location":"manual/NEWS/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"manual/NEWS/#Version-0.1.1-(2025-12-16)","page":"Release notes","title":"Version 0.1.1 (2025-12-16)","text":"Minor updates to README.md and the documentation.\nRemoval of data compliance of TransmissionMode due to the changes from EnergyModelsBase v0.9.1 and the corresponding adjustment in EnergyModelsGeography v0.11.3.","category":"section"},{"location":"manual/NEWS/#Version-0.1.0-(2025-03-27)","page":"Release notes","title":"Version 0.1.0 (2025-03-27)","text":"Initial version of the package:\n\nInclusion of compliance checks for new Nodes, Links, Areas, and TransmissionModes:\nThe checks highlight whether a Node, Link, Areas or TransmissionMode can work with existing functions.\nThe checks mostly provide warnings, as errors are dependent on the chosen functions from EnergyModelsBase or EnergyModelsGeography.\nInclusion of simple test cases for Node and TransmissionMode:\nThe test cases can be used to see whether the couplings in EnergyModelsBase and EnergyModelsGeography are working.\nThe test cases ensure that the capacity of the elements is utilized.","category":"section"}]
}
